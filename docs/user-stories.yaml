user_roles:
  - name: Primary User
    description: Presses buttons, uses switches, runs apps.
  - name: System Admin
    description: Manages mappings, handles power/reset, remote config.
  - name: Developer
    description: Adds apps, extends system APIs.

user_stories:
  - id: US-001
    title: Development Environment & Hardware Emulation
    as: developer
    want: Run B.O.S.S. on my Windows laptop using an emulated GPIO environment
    so_that: I can develop and test the software without requiring physical hardware at all times.
    priority: High
    acceptance_criteria:
      - The system detects when it is running in a non-RPi environment and disables/hides actual hardware calls.
      - A simulated input module is available that mimics button presses and switch state changes.
      - Automated tests pass in the emulated environment.
    status: Complete
    notes: SwitchReader abstraction (with mock) reads the 8-switch value. SevenSegmentDisplay abstraction (with mock) displays the value. AppManager polls the switch and updates the display when the value changes. Tests verify that the display updates only when the switch value changes.

  - id: US-002
    title: Initial Hardware Setup & GPIO Initialization
    as: developer
    want: Initialize GPIO, buttons, and the display on startup (via main.py)
    so_that: The core system is ready for user interaction as soon as booted.
    priority: High
    acceptance_criteria:
      - On system startup, all hardware interfaces are properly instantiated and logged.
      - The 7-segment display shows the current switch value immediately.
    status: Complete

  - id: US-003
    title: Toggle Switch Selection
    as: user
    want: Use 8 toggle switches to select a number (0â€“255)
    so_that: I can choose the mini-app I want to run.
    priority: High
    acceptance_criteria:
      - The multiplexer (74HC151) reads the toggle switches correctly.
      - The computed number is accurate and displayed immediately on the TM1637 7-segment display.
    status: Complete
    notes: Implemented SwitchReader abstraction and polling logic in AppManager to read and display the switch value.

  - id: US-004
    title: App Launch (Go Button)
    as: user
    want: Press the main "Go" button to launch the mini-app mapped to the current switch value
    so_that: I have direct control over which mini-app is executed.
    priority: High
    acceptance_criteria:
      - Pressing the "Go" button starts the app selected in configuration.
      - If an app is running, the "Go" button stops the current app before launching another.
    status: Complete
    notes: Implemented MockButton and GoButtonManager to handle Go button presses, app launch, and termination. Includes unit tests for button logic.

  - id: US-005
    title: Dynamic App Execution and Termination
    as: user
    want: Have the running mini-app terminated upon a new "Go" button press or timeout
    so_that: I can easily switch between apps without conflicts or lingering processes.
    priority: High
    acceptance_criteria:
      - The app shutdown sequence is executed when the button is pressed again.
      - In the event of an app exceeding its runtime, it is forcefully terminated and logged.
    status: Complete
    notes: Implemented AppRunner to manage app threads, handle stop events, and force termination with logging. Unit tests verify app start, stop, and forced termination behavior.

  - id: US-006
    title: Real-Time Feedback on 7-Segment Display & Screen
    as: user
    want: Receive immediate visual feedback on both the 7-segment display and the 7-inch screen
    so_that: I know the system is correctly registering my inputs and providing status updates.
    priority: Medium
    acceptance_criteria:
      - The 7-segment display updates in real time in response to switch changes.
      - Status messages and app outputs appear properly on the 7-inch screen.
    status: Complete
    notes: Implemented MockScreen abstraction for the 7-inch screen, with methods for status and app output. Unit tests verify real-time feedback logic.

  - id: US-007
    title: Standardized App API & Plugin Structure
    as: developer
    want: Have mini-apps load dynamically from the apps/ directory and follow a standard interface (e.g., run(stop_event, api))
    so_that: New apps can be added or updated without modifying core code.
    priority: High
    acceptance_criteria:
      - Each app exposes a standard entry function or a class-based interface.
      - A minimal JSON manifest is provided with each app (e.g., name, description, hardware used).
      - The core system successfully loads and runs apps, as shown in integration tests.
    status: Complete
    notes: Added ConfigManager for JSON config management, with tests.

  - id: US-008
    title: App Mapping Configuration via JSON
    as: developer
    want: Store the mapping of switch values to mini-apps, including parameters, in a JSON configuration file
    so_that: Configuration is clear, easily editable, and decoupled from the application logic.
    priority: High
    acceptance_criteria:
      - The system reads from a JSON file (e.g., BOSSsettings.json) at startup.
      - Default mappings are generated if the configuration file is missing or malformed.
      - Changing the JSON file and reloading the system updates the app mappings.
    status: Complete
    notes: Apps can be added as new modules in apps/ (see app_example.py), no core changes required.

  - id: US-009
    title: Remote Device Management
    as: system administrator
    want: Remotely access a secure REST API exposed by the device
    so_that: I can monitor status, update configuration, and manage running apps without physical access.
    priority: Medium
    acceptance_criteria:
      - A secure REST endpoint is available for device status, app mapping, and log access.
      - Authentication is enforced on all API endpoints.
      - Changes made via the API are reflected in the system behavior without requiring a reboot.

  - id: US-010
    title: OTA App Sync & Update (Future Enhancement)
    as: system administrator
    want: Have the ability to sync new or updated mini-apps over-the-air
    so_that: The device can be kept up-to-date without manual intervention.
    priority: Low
    acceptance_criteria:
      - A mechanism is in place for securely fetching and updating app modules from a remote repository.
      - The update process does not interrupt device operation more than necessary.
    status: Planned

  - id: US-011
    title: Unit and Integration Testing for Core Modules
    as: developer
    want: Have comprehensive unit tests for hardware abstraction and core logic
    so_that: Changes can be confidently made, and regressions are prevented.
    priority: High
    acceptance_criteria:
      - Unit tests cover all critical components (e.g., SwitchReader, Button, LED).
      - Integration tests exist for app loading/execution cycles.
      - Tests run in CI (e.g., via GitHub Actions).
    status: Complete
    notes: Implemented LED abstraction (with mock for dev) and tests for LED state changes.

  - id: US-012
    title: Documentation and Onboarding Materials
    as: new contributor
    want: Have an up-to-date README, architecture overview, and in-code documentation
    so_that: I can understand the project quickly and contribute effectively.
    priority: High
    acceptance_criteria:
      - A README file provides project setup instructions, dependency lists, and architectural diagrams.
      - User stories and technical specifications are maintained in docs (e.g., docs/user-stories.md).
      - Code is documented with docstrings and type hints.

  - id: US-013
    title: Developer Tooling and Emulated Inputs for CI
    as: developer
    want: Have utility scripts and emulation layers for simulating button presses and switches
    so_that: I can develop and test the system without constant access to the physical hardware.
    priority: Medium
    acceptance_criteria:
      - Emulation modules are available for GPIO input.
      - Developer scripts can simulate hardware inputs and verify system responses.

  - id: US-014
    title: Robust Error Handling and Safe Shutdown
    as: user
    want: Know that hardware errors or app crashes trigger safe shutdown or fallback states
    so_that: The device isn't damaged and user data is protected.
    priority: High
    acceptance_criteria:
      - All hardware interfaces use robust try/except mechanisms.
      - Logs capture any errors and provide clear diagnostic information.
      - A safe fallback state is activated on hardware errors.

  - id: US-015
    title: Secure Remote API Authentication
    as: system administrator
    want: Authenticate users accessing the remote management API
    so_that: Unauthorized users cannot alter device configurations or retrieve sensitive data.
    priority: High
    acceptance_criteria:
      - All remote API endpoints require secure authentication (e.g., JWT tokens).
      - API documentation details the authentication process.
      - Attempts to access endpoints without proper credentials are denied and logged.

  - id: US-016
    title: Central Logging Initialization
    as: developer or system administrator
    want: Initialize a central logging facility at system startup
    so_that: All events, errors, and important actions are recorded for debugging and support.
    priority: High
    acceptance_criteria:
      - Logging is initialized before any hardware or app logic runs.
      - All modules use the central logger for output.
      - Log files are rotated and stored persistently.
      - Logging level can be configured (e.g., debug, info, error).
    status: Complete
    notes: Implemented a central logger with rotation and configurable levels. All startup, shutdown, and error events are logged. Tests verify log output.

  - id: US-017
    title: Clean Shutdown and Resource Cleanup
    as: user or system administrator
    want: Ensure the system performs a clean shutdown and resource cleanup (hardware, threads, files) when stopping
    so_that: Hardware is left in a safe state and no data is lost.
    priority: High
    acceptance_criteria:
      - All hardware interfaces are properly closed or reset on shutdown.
      - Running apps and threads are terminated gracefully.
      - Any unsaved data is written to disk.
      - Shutdown events are logged.
    status: Complete
    notes: System startup and shutdown logic added to main.py, using the central logger. Cleanup is performed on exit and all actions are logged.

  - id: US-018
    title: Document GPIO and Apply
    as: developer
    want: Know how to connect the various components to the Rpi GPIO pins
    so_that: The components are connected safely and work as expected
    priority: High
    acceptance_criteria:
      - GPIO connections are documented appropriately (See: docs.md, RPi-GPIO-Pin-Diagram.md)
      - GPIO is configured in the application for all components
    status: Complete
    notes: See docs.md for table and wiring notes. See RPi-GPIO-Pin-Diagram.md for full pinout.

  - id: US-019
    title: Mini-app for Displaying Random Data
    as: user
    want: Select a number for my choice of mini-app. When I press the "go" button, I want see a random joke from a long list of jokes that are stored in the system.
    acceptance_criteria:
      - When I toggle the switches, I see the corresponding number on the 7-segment display
      - When I press the "go" button, I see the joke displayed on the 7-inch screen
    implementation_notes:
      - Switch Mapping: The app should be mapped to a number in config/BOSSsettings.json. For this app, use number 001.
      - Joke Storage: The list of jokes will be a JSON file, stored in the relevant app's folder. There should be an assets folder under the app's sub-folder. A sample JSON file with temporary jokes will be created for initial testing.
      - Display: There will be a requirement to format the text with colour, size, and position in the future. Initially, if no other formats are applied, the text should be centred on the screen and remain until another app is launched.
      - App Structure: All mini-apps should follow the same structure that allows them to be run and terminated by BOSS. No additional user interaction at this time, but future enhancements may allow user-triggered results.
      - Testing: Tests should detect hardware and use mock or real hardware accordingly.

  - id: US-020
    title: Support Multiple Display Backends (Pillow only)
    as: developer or app creator
    want: Use Pillow for rendering graphics in my mini-apps
    so_that: Each app can use the most suitable library for its display needs.
    priority: Medium
    acceptance_criteria:
      - Pillow is installed and available in the environment.
      - The system API provides a Pillow display context.
      - Example apps demonstrate use of both backends.
    status: Planned

  - id: US-021
    title: Advanced Text Display Options in API
    as: developer or app creator
    want: Have flexible options for displaying text on the screen (e.g., centering, positioning, color, effects)
    so_that: Mini-apps can present information in a visually appealing and context-appropriate way
    priority: Medium
    acceptance_criteria:
      - The API allows text to be centered horizontally and/or vertically.
      - Text can be positioned at specific (x, y) coordinates.
      - Font color and background color can be set via the API.
      - Font size and font family can be specified.
      - Text alignment (left, center, right) is supported for multi-line text.
      - Text effects such as bold, italic, underline, and shadow are available.
      - The API supports multi-line and word-wrapped text.
      - Opacity/transparency can be set for text and background.
      - The API allows displaying text with an outline or border.
      - Emoji and Unicode symbols are supported in text rendering.
      - Example mini-apps demonstrate at least three of these features.
    notes: These features should be available for the Pillow display backend. The API should provide sensible defaults and allow easy extension for future display features.

  - id: US-022
    title: Image Display Support in API
    as: developer or app creator
    want: Display images on the screen with flexible options for scaling, positioning, and appearance
    so_that: Mini-apps can show pictures, icons, or graphics in a visually appropriate way regardless of the original image size
    priority: Medium
    acceptance_criteria:
      - The API allows displaying images (e.g., PNG, JPEG, BMP) on the screen.
      - If the image size does not match the screen, the API automatically scales the image to fit or fill the screen, preserving aspect ratio by default.
      - The API provides options for scaling modes: fit, fill, stretch, or center without scaling.
      - Images can be positioned at specific (x, y) coordinates or centered horizontally/vertically.
      - The API supports setting a background color or transparency for images with alpha channels.
      - The API allows drawing images with rounded corners or as circles/ellipses.
      - Example mini-apps demonstrate at least two of these features.
    notes: These features should be available for the Pillow backend. The API should handle common image formats and provide sensible defaults for scaling and placement.

  - id: US-023
    name: startup_update_check
    title: Check for Software Updates at Startup
    description: >
      On BOSS application startup, check the associated GitHub repository for newer versions and visually notify the user if updates are available.
    trigger:
      type: startup_hook
    behavior:
      - fetch_remote_git_commit
      - compare_with_local_commit
      - display_update_notification:
          when: remote_commit_is_newer

  - id: US-024
    name: startup_network_check
    title: Check Network Connectivity at Startup
    description: >
      Verifies internet availability when BOSS starts up, displaying a warning message if the system is offline.
    trigger:
      type: startup_hook
    behavior:
      - check_interface_status: wlan0
      - ping_external_host: "8.8.8.8"
      - display_status_message:
          if_failed: "No internet connection detected. Please connect to Wi-Fi to ensure full functionality."

# ===================================================================
# EPIC: Rich Display Backend Implementation
# ===================================================================

  - id: US-025
    title: Rich Display Backend Architecture
    as: developer
    want: Create a new Rich-based screen implementation alongside the existing Pillow implementation
    so_that: Apps can choose the most appropriate display backend for their needs
    priority: High
    epic: Rich Display Backend
    acceptance_criteria:
      - A new GPIORichScreen class is created that implements ScreenInterface
      - GPIORichScreen uses the rich library for text rendering instead of Pillow
      - Both GPIOScreen (Pillow) and GPIORichScreen (Rich) can coexist in the system
      - The hardware factory can create either implementation based on configuration
      - Rich implementation handles console output redirected to the framebuffer or terminal
      - All existing ScreenInterface methods are implemented with Rich equivalents
    tasks:
      - Create boss/infrastructure/hardware/gpio/gpio_rich_screen.py
      - Implement GPIORichScreen class with ScreenInterface
      - Add rich library imports and console initialization
      - Implement display_text() using rich.console.Console
      - Implement clear_screen() using rich console clearing
      - Implement get_screen_size() for rich console dimensions
      - Add proper error handling and logging
      - Create unit tests for GPIORichScreen class
      - Update gpio_factory.py to support Rich screen creation

  - id: US-026
    title: Configuration-Based Screen Backend Selection
    as: system administrator
    want: Configure which screen backend (Pillow or Rich) the system uses via configuration
    so_that: I can choose the optimal display technology for my deployment without code changes
    priority: High
    epic: Rich Display Backend
    acceptance_criteria:
      - A new "screen_backend" configuration option is added to boss_config.json
      - Valid values are "pillow" and "rich" (default: "pillow" for backward compatibility)
      - The hardware factory creates the appropriate screen implementation based on this setting
      - Invalid configuration values log an error and fall back to Pillow
      - Configuration validation ensures only supported backends are specified
      - Hot-reload of configuration updates the screen backend without restart
    tasks:
      - Add screen_backend field to HardwareConfig model
      - Update boss/config/boss_config.json with screen_backend option
      - Modify config validation to check screen_backend values
      - Update hardware factory to read screen_backend configuration
      - Implement factory logic to create GPIOScreen or GPIORichScreen based on config
      - Add configuration validation with helpful error messages
      - Update configuration loading tests
      - Add integration tests for backend switching
      - Document configuration options in config comments

  - id: US-027
    title: App Manifest Screen Backend Preference
    as: app developer
    want: Specify in my app's manifest.json which screen backend I prefer
    so_that: My app can automatically use the display technology best suited for its content
    priority: Medium
    epic: Rich Display Backend
    acceptance_criteria:
      - App manifest.json can include "preferred_screen_backend" field
      - Valid values are "pillow", "rich", or "auto" (auto uses system default)
      - App Manager reads the preference during app loading
      - The screen backend is switched temporarily while the app runs
      - When the app exits, the system reverts to the configured default backend
      - Apps without a preference use the system default backend
      - Invalid preferences log a warning and use system default
    tasks:
      - Update app manifest schema to include preferred_screen_backend
      - Modify app loader to read screen backend preference
      - Update App domain model to store screen backend preference
      - Implement screen backend switching in AppRunner
      - Add logic to revert to default backend on app exit
      - Create app manifest validation for screen backend values
      - Update app template manifest.json with example preference
      - Add unit tests for app screen backend preference handling
      - Update app development documentation with manifest options

  - id: US-028
    title: Rich Console Features Implementation
    as: app developer
    want: Access Rich-specific features like tables, progress bars, syntax highlighting, and rich formatting
    so_that: I can create visually appealing console-style interfaces with structured data display
    priority: Medium
    epic: Rich Display Backend
    acceptance_criteria:
      - Rich screen backend supports displaying Rich Table objects
      - Rich screen backend supports Progress bars and status indicators
      - Rich screen backend supports syntax highlighting for code display
      - Rich screen backend supports Rich markup (colors, bold, italic)
      - Rich screen backend supports panels and borders
      - Rich screen backend supports tree structures for hierarchical data
      - Extended API methods are available for Rich-specific features
      - Fallback behavior is provided when Rich features are used with Pillow backend
    tasks:
      - Extend GPIORichScreen with display_table() method
      - Implement display_progress() for progress bars
      - Add display_code() method with syntax highlighting
      - Implement display_panel() for bordered content
      - Add display_tree() for hierarchical data structures
      - Create display_markup() for rich text formatting
      - Implement console layout and column management
      - Add Rich feature detection and graceful fallbacks
      - Create examples demonstrating each Rich feature
      - Update ScreenInterface with Rich-specific optional methods

  - id: US-029
    title: Rich Console Output Redirection
    as: system developer
    want: Ensure Rich console output is properly directed to the HDMI screen on Raspberry Pi
    so_that: Rich-rendered content appears on the physical display instead of SSH terminal
    priority: High
    epic: Rich Display Backend
    acceptance_criteria:
      - Rich console output is redirected to the framebuffer device (/dev/fb0)
      - Rich content appears on the physical HDMI screen, not SSH terminal
      - Rich console respects the configured screen dimensions
      - Console output is properly formatted for the target display resolution
      - Color output is correctly mapped to the display color space
      - Rich console works in headless mode without SSH connection
      - Performance is acceptable for real-time display updates
    tasks:
      - Research Rich console output redirection techniques
      - Implement framebuffer output capture for Rich console
      - Configure Rich console with proper screen dimensions
      - Set up Rich console for headless operation
      - Implement color space mapping for framebuffer output
      - Add performance optimization for framebuffer writes
      - Test Rich output on actual Raspberry Pi hardware
      - Create benchmarks comparing Rich vs Pillow performance
      - Document framebuffer redirection approach

  - id: US-030
    title: Rich and Pillow Feature Parity
    as: app developer
    want: Have equivalent functionality available regardless of which screen backend I choose
    so_that: I can switch backends without losing essential display capabilities
    priority: Medium
    epic: Rich Display Backend
    acceptance_criteria:
      - Both backends support text display with size, color, and positioning
      - Both backends support screen clearing with background colors
      - Both backends support multi-line text and text alignment
      - Image display gracefully degrades in Rich (shows filename or placeholder)
      - Rich backend provides text-based alternatives for graphical features
      - Performance characteristics are documented for both backends
      - API compatibility layer ensures seamless backend switching
    tasks:
      - Audit existing Pillow features for Rich equivalents
      - Implement Rich text positioning equivalent to Pillow coordinates
      - Create Rich color mapping for Pillow color specifications
      - Implement image placeholder display in Rich backend
      - Add text alignment options for Rich backend
      - Create font size mapping between Pillow and Rich
      - Implement compatibility layer for seamless API usage
      - Add feature comparison documentation
      - Create migration guide for apps switching backends

  - id: US-031
    title: Rich Backend Performance Optimization
    as: system administrator
    want: Rich display backend to perform efficiently on Raspberry Pi hardware
    so_that: The system remains responsive even with complex Rich console output
    priority: Medium
    epic: Rich Display Backend
    acceptance_criteria:
      - Rich backend renders content within 100ms for typical text displays
      - Rich backend uses less than 50MB additional memory compared to Pillow
      - Rich backend updates do not cause noticeable lag in the user interface
      - Rich backend handles rapid display updates without buffer overflow
      - Rich backend gracefully handles complex layouts without system slowdown
      - Performance metrics are logged for monitoring and optimization
    tasks:
      - Profile Rich backend memory usage vs Pillow
      - Benchmark Rich rendering performance on Raspberry Pi
      - Implement Rich console buffer optimization
      - Add asynchronous rendering for complex Rich layouts
      - Optimize Rich console refresh rates
      - Implement display update batching for Rich backend
      - Add performance monitoring and logging
      - Create performance comparison documentation
      - Implement automatic performance degradation for complex content

  - id: US-032
    title: Rich Backend Testing and Validation
    as: developer
    want: Comprehensive tests for Rich display backend functionality
    so_that: Rich backend is reliable and regressions are prevented
    priority: High
    epic: Rich Display Backend
    acceptance_criteria:
      - Unit tests cover all GPIORichScreen methods
      - Integration tests verify Rich backend works with app lifecycle
      - Mock tests allow Rich backend testing without hardware
      - Visual regression tests ensure Rich output consistency
      - Performance tests validate Rich backend efficiency
      - Cross-platform tests ensure Rich works on development machines
      - CI pipeline includes Rich backend test execution
    tasks:
      - Create unit tests for GPIORichScreen class
      - Implement Rich console mocking for tests
      - Add integration tests for Rich backend with apps
      - Create visual output comparison tests
      - Implement performance benchmarking tests
      - Add Rich backend tests to CI pipeline
      - Create test fixtures for Rich console validation
      - Implement Rich output capture for test verification
      - Add error condition testing for Rich backend

  - id: US-033
    title: Rich Backend Developer Experience
    as: app developer
    want: Clear documentation, examples, and tools for using Rich display backend
    so_that: I can effectively develop apps that leverage Rich's capabilities
    priority: Medium
    epic: Rich Display Backend
    acceptance_criteria:
      - Rich backend API is fully documented with examples
      - Code examples demonstrate Rich-specific features
      - Migration guide helps convert Pillow apps to use Rich
      - Best practices guide covers Rich performance optimization
      - Development tools support Rich backend testing
      - Rich backend features are documented in app development guide
    tasks:
      - Create Rich backend API documentation
      - Write Rich feature demonstration apps
      - Create Pillow-to-Rich migration guide
      - Document Rich backend performance best practices
      - Add Rich backend examples to app template
      - Update app development documentation with Rich guidance
      - Create Rich backend troubleshooting guide
      - Add Rich backend support to development tools

  - id: US-034
    title: Rich Backend Installation and Dependencies
    as: system administrator
    want: Clear installation instructions and dependency management for Rich backend
    so_that: I can deploy systems with Rich backend support without dependency conflicts
    priority: High
    epic: Rich Display Backend
    acceptance_criteria:
      - Rich library is added to project dependencies with proper version constraints
      - Installation documentation includes Rich backend setup steps
      - Dependency conflicts between Rich and existing libraries are resolved
      - Rich backend dependencies are optional when not needed
      - Virtual environment setup includes Rich installation
      - Docker configuration supports Rich backend
      - Installation validation confirms Rich backend functionality
    tasks:
      - Add rich library to requirements.txt with version constraints
      - Update setup scripts to install Rich dependencies
      - Test Rich installation on clean Raspberry Pi OS
      - Update Docker configuration for Rich support
      - Add Rich installation to systemd service setup
      - Create Rich installation validation script
      - Update remote development setup to include Rich
      - Document Rich version compatibility requirements
      - Add Rich installation troubleshooting guide

  - id: US-035
    title: Rich Backend Documentation and Installation Guide
    as: developer or system administrator
    want: Comprehensive documentation for Rich backend implementation, configuration, and usage
    so_that: I can successfully deploy, configure, and develop with Rich backend support
    priority: High
    epic: Rich Display Backend
    acceptance_criteria:
      - Installation guide includes Rich library setup and dependencies
      - Configuration documentation covers screen_backend options
      - App development guide explains Rich vs Pillow backend selection
      - Performance comparison documentation helps choose appropriate backend
      - Troubleshooting guide covers common Rich backend issues
      - API reference documents all Rich-specific methods and features
      - Migration guide helps transition existing apps to Rich backend
      - Best practices documentation covers Rich optimization techniques
    tasks:
      - Update README.md with Rich backend overview
      - Add Rich installation steps to setup documentation
      - Create docs/rich_display_backend.md comprehensive guide
      - Update configuration documentation with screen_backend options
      - Add Rich backend section to app development guide
      - Create Rich vs Pillow comparison documentation
      - Write Rich backend troubleshooting guide
      - Update API documentation with Rich-specific methods
      - Create Rich backend migration guide for existing apps
      - Add Rich backend examples to documentation
      - Update Copilot instructions with Rich backend information
      - Create Rich backend quick reference guide




# End of Backlog
